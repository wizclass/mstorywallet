# Installing

```bash
$ yarn install
$ yarn lerna bootstrap
```

# Running tests

Modules typically provide both unit and integration tests.

The rule of thumb for whether a test is a unit test or an integration test is whether or not the test makes a real network request to another system. If it does, it's probably an integration test, otherwise it's a unit test.

You can run unit tests for each individual module:
```bash
$ yarn run unit-test --scope bitgo
```

You can also run unit tests for all modules in parallel:
```bash
$ yarn run unit-test
```

Or just the modules which have changed since master:
```bash
$ yarn run unit-test-changed
```

**Note:** Each module's output will be prefixed with it's name, but it may be difficult to unmangle the test output.

To aid with evaluating test results, and especially test failures, a fancy test report is generated by the CI system and uploaded to S3.

The link to this report is output in the "upload reports" stage of each build pipeline.

Here is an example of this output:
```
@bitgo/express: === TEST REPORT UPLOADED SUCCESSFULLY ===
@bitgo/express: https://bitgo-sdk-test-reports.s3.amazonaws.com/1036/express/unit tests (node:6).html
```

# Working with modules

## Should I make a new module for my contribution?

This is a question you should ask before making large changes to the SDK. The original goal of modularizing the SDK was
to allow users to only include support for the features they actually want to use, instead of bringing in hundreds of
megabytes of dependencies which they won't use.

Therefore, if your feature meets the following criteria, then it is a good candidate for being its own module.
Otherwise, perhaps not.

1. Will this feature require additional dependencies to be added? How heavy are those dependencies?
1. Is this feature something which would only be used by a small fraction of SDK users?
1. Is this feature extending existing bitgo functionality, or is it providing entirely new functionality? For example,
   adding a new coin would be extending existing bitgo functionality.

These recommendations are just that, recommendations. Please use your best judgement when it comes to how your change is
architected.

## Module Configuration
Each module should have the following basic file structure:
```
- modules/
  - mymodule/
    - src/
      - index.ts
    - test/
      - unit/
        - test-feature.ts
      - integration/
        - test-feature.ts
    - package.json
    - README.md
```

## `package.json`

* ### `name`
For a binary application module named "fooapp", this should be set to `@bitgo/fooapp`.

For a generic library module named "bar", this should be set to `@bitgo/sdk-lib-bar`.

For a coin library module which supports a coin with ticker "BAZ", this should be set to `@bitgo/sdk-coin-baz`.

* ### `scripts`

These npm scripts may be run during lifecycle events and by lerna across all modules. If a script is not present in a module, that module will be skipped.

| Name | Description | Required? |
| --- | --- | --- |
| `test` / `unit-test` | Run module unit tests | Yes |
| `integration-test` | Run module integration tests. These are run when a PR is targeted to merge against master. | No |
| `prepare` / `build` | Compile typescript sources | No |
| `clean` | Clean up generated build files | No |
| `audit` | Run a vulnerability against the module dependencies | Yes | 
| `gen-coverage` | Generate a code coverage report | No |
| `upload-coverage` | Upload a code coverage report | No |
| `upload-artifacts` | Upload any artifacts produced by the build and test process | No |

Additional scripts which are too large for the package.json file should be placed in `scripts/` and should be plain javascript or bash.

* ### `repository`

This shall always be set for all modules to:
```json
{
  "repository": {
    "type": "git",
    "url": "https://github.com/BitGo/BitGoJS.git"
  }
}
```

* ### `license`

License shall be `Apache-2.0`.

* ### `engines`

Engines should be set to the following:
```json
{
  "engines": {
    "node": ">=6.12.3 <13.0.0",
    "npm": ">=3.10.10"
  }
}
```

## `tsconfig.json`

There are a few things each module's `tsconfig.json` must do:
* Extend the root tsconfig.json
* Set the `outDir` and `rootDir` compiler options
* Set the `include` property to the correct module source directories (`package.json` should also be included if it is read at runtime)

Here is a template to help get started:
```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "."
  },
  "include": [
    "src/**/*",
    "package.json"
  ]
}
```
